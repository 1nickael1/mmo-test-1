import{e as T,m as C,i as I,n as S,b}from"./D3nKW_CT.js";import{X as y,Y as U,Z as g,$ as x,f as P,a0 as _,r as v,p as E,v as $,s as F,e as R,x as k,H as j}from"#entry";function z(){let t=document.activeElement;if(t==null)return null;for(;t!=null&&t.shadowRoot!=null&&t.shadowRoot.activeElement!=null;)t=t.shadowRoot.activeElement;return t}const[K]=T("ConfigProvider");function D(t){const e=y(),s=e?.type.emits,i={};return s?.length||console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),s?.forEach(u=>{i[U(g(u))]=(...o)=>t(u,...o)}),i}function L(t){const e=y(),s=Object.keys(e?.type.props??{}).reduce((u,o)=>{const n=(e?.type.props[o]).default;return n!==void 0&&(u[o]=n),u},{}),i=x(t);return P(()=>{const u={},o=e?.vnode.props??{};return Object.keys(o).forEach(n=>{u[g(n)]=o[n]}),Object.keys({...s,...u}).reduce((n,l)=>(i.value[l]!==void 0&&(n[l]=i.value[l]),n),{})})}function X(t,e){const s=L(t),i=e?D(e):{};return P(()=>({...s.value,...i}))}function Z(t,e="reka"){return t||`${e}-${_?.()}`}function V(t,e){const s=v(t);function i(o){return e[s.value][o]??s.value}return{state:s,dispatch:o=>{s.value=i(o)}}}function W(t,e){const s=v({}),i=v("none"),u=v(t),o=t.value?"mounted":"unmounted";let n;const l=e.value?.ownerDocument.defaultView??C,{state:d,dispatch:c}=V(o,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),r=a=>{if(I){const m=new CustomEvent(a,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(m)}};E(t,async(a,m)=>{const N=m!==a;if(await F(),N){const A=i.value,f=h(e.value);a?(c("MOUNT"),r("enter"),f==="none"&&r("after-enter")):f==="none"||f==="undefined"||s.value?.display==="none"?(c("UNMOUNT"),r("leave"),r("after-leave")):m&&A!==f?(c("ANIMATION_OUT"),r("leave")):(c("UNMOUNT"),r("after-leave"))}},{immediate:!0});const p=a=>{const m=h(e.value),N=m.includes(CSS.escape(a.animationName)),A=d.value==="mounted"?"enter":"leave";if(a.target===e.value&&N&&(r(`after-${A}`),c("ANIMATION_END"),!u.value)){const f=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",n=l?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=f)})}a.target===e.value&&m==="none"&&c("ANIMATION_END")},w=a=>{a.target===e.value&&(i.value=h(e.value))},M=E(e,(a,m)=>{a?(s.value=getComputedStyle(a),a.addEventListener("animationstart",w),a.addEventListener("animationcancel",p),a.addEventListener("animationend",p)):(c("ANIMATION_END"),n!==void 0&&l?.clearTimeout(n),m?.removeEventListener("animationstart",w),m?.removeEventListener("animationcancel",p),m?.removeEventListener("animationend",p))},{immediate:!0}),O=E(d,()=>{const a=h(e.value);i.value=d.value==="mounted"?a:"none"});return $(()=>{M(),O()}),{isPresent:P(()=>["mounted","unmountSuspended"].includes(d.value))}}function h(t){return t&&getComputedStyle(t).animationName||"none"}var G=R({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:s}){const{present:i,forceMount:u}=k(t),o=v(),{isPresent:n}=W(i,o);s({present:n});let l=e.default({present:n.value});l=S(l||[]);const d=y();if(l&&l?.length>1){const c=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${c}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(r=>`  - ${r}`).join(`
`)].join(`
`))}return()=>u.value||i.value||n.value?j(e.default({present:n.value})[0],{ref:c=>{const r=b(c);return typeof r?.hasAttribute>"u"||(r?.hasAttribute("data-reka-popper-content-wrapper")?o.value=r.firstElementChild:o.value=r),r}}):null}});export{G as P,D as a,L as b,X as c,z as g,K as i,Z as u};
